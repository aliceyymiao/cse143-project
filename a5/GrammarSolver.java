// Yingyun(Alice) Miao
// 2/12/19
// CSE143
// TA: Chin Yeoh
// Assignment #5
//
// The class called GrammarSolver allows the user to randomly
// generate elements of the grammar to construct sentence and 
// word combinations.
 
import java.util.*;

public class GrammarSolver{
   private SortedMap<String, String[]> symbolRule;
   
   // pre: the grammar is not empty and there is 
   //      only one entry in the grammar for the 
   //      same nonterminal, otherwise throw an 
   //      IllegalArgumentException.
   // post: takes in a String list grammar in BNF structure. 
   //       A standard BNF format has a nonterminal symbol
   //       on the left-hand-side and a series of rules separated
   //       by ("|") on the right. BNF use "::=" to separate the 
   //       symbol from the rules if there is no "|". Stores the 
   //       nonterminal symbols and their matching groups of rules
   //       with the given grammar
   public GrammarSolver(List<String> grammar) {
      if (grammar.isEmpty()) {
         throw new IllegalArgumentException();
      }
      symbolRule = new TreeMap<String, String[]>();
      for (String s : grammar) {
         String[] parts = s.split("::=");
         if (symbolRule.containsKey(parts[0])) {
            throw new IllegalArgumentException();
         }
         String[] part = parts[1].split("[|]");
         symbolRule.put(parts[0], part);
      }
   }
   
   // takes in a String symbol, returns true if the 
   // given symbol is a nonterminal of the grammar;
   // return false otherwise
   public boolean grammarContains(String symbol) {
      return symbolRule.containsKey(symbol);
   }
   
   // pre: the grammar contains the given nonterminal
   //      symbol and the number of times is not less
   //      than 0, otherwise throw an IllegalArgumentException
   // post: takes in a String symbol and an integer times, 
   //       randomly generate the given number of occurrences
   //       of the given symbol and return the result as an
   //       array of strings
   public String[] generate(String symbol, int times) {
      if (!grammarContains(symbol) || times < 0) {
         throw new IllegalArgumentException();
      }
      String[] generateSentence = new String[times];
      Random rand = new Random();
      for (int i = 0; i < times; i++) {
         generateSentence[i] = generate(symbol, rand);
      }
      return generateSentence;
   }
   
   // takes in a String symbol, returns a line
   // generated by given grammar rules according
   // to the given symbol
   private String generate(String symbol, Random rand) { 
      String[] rule = symbolRule.get(symbol);
      int number = rand.nextInt(rule.length);
      String[] line = rule[number].trim().split("[ \t]+");
      String finalResult = "";
      for (String s : line) {
         if (grammarContains(s)) {
            finalResult += " " + generate(s, rand);
         } else {
            finalResult += " " + s;
         }
      }
      return finalResult.trim();
   }
   
   // returns a string representation of
   // the various nonterminal symbols from
   // the grammar as sorted, comma-separated
   // list enclosed in square brackets  
   public String getSymbols() {
      return symbolRule.keySet().toString();
   }
}